// /*
//  * Copyright 2018-2022 Copenhagen Center for Health Technology (CACHET) at the
//  * Technical University of Denmark (DTU).
//  * Use of this source code is governed by a MIT-style license that can be
//  * found in the LICENSE file.
//  */

// part of runtime;

// /// Returns the relevant [TriggerExecutor] based on the type of [trigger].
// TriggerExecutor getTriggerExecutor(TriggerConfiguration trigger) {
//   switch (trigger.runtimeType) {
//     case ElapsedTimeTrigger:
//       return ElapsedTimeTriggerExecutor();
//     case ScheduledTrigger:
//       warning("ScheduledTrigger is not implemented yet. "
//           "Using an 'ImmediateTriggerExecutor' instead.");
//       return ImmediateTriggerExecutor();
//     case ImmediateTrigger:
//       return ImmediateTriggerExecutor();
//     case OneTimeTrigger:
//       return OneTimeTriggerExecutor();
//     case DelayedTrigger:
//       return DelayedTriggerExecutor();
//     case IntervalTrigger:
//       return IntervalTriggerExecutor();
//     case PeriodicTrigger:
//       return PeriodicTriggerExecutor();
//     case DateTimeTrigger:
//       return DateTimeTriggerExecutor();
//     case RecurrentScheduledTrigger:
//       return RecurrentScheduledTriggerExecutor();
//     case CronScheduledTrigger:
//       return CronScheduledTriggerExecutor();
//     case SamplingEventTrigger:
//       return SamplingEventTriggerExecutor();
//     case ConditionalSamplingEventTrigger:
//       return ConditionalSamplingEventTriggerExecutor();
//     case ConditionalPeriodicTrigger:
//       return ConditionalPeriodicTriggerExecutor();
//     case RandomRecurrentTrigger:
//       return RandomRecurrentTriggerExecutor();
//     case PassiveTrigger:
//       return PassiveTriggerExecutor();
//     case UserTaskTrigger:
//       return UserTaskTriggerExecutor();

//     default:
//       warning(
//           "Unknown trigger used - cannot find a TriggerExecutor for the trigger of type '${trigger.runtimeType}'. "
//           "Using an 'ImmediateTriggerExecutor' instead.");
//       return ImmediateTriggerExecutor();
//   }
// }

// // ---------------------------------------------------------------------------------------------------------
// // TRIGGER EXECUTORS
// // ---------------------------------------------------------------------------------------------------------

// /// Responsible for handling the execution of a trigger.
// ///
// /// This is an abstract class. For each specific type of [TriggerConfiguration],
// /// a corresponding implementation of this class exists.
// abstract class TriggerExecutor<TConfig extends TriggerConfiguration>
//     extends AggregateExecutor<TConfig> {
//   // /// An ordered list of timestamp generated by this trigger for a
//   // /// given period. This is mainly used for persistently scheduling
//   // /// a list of [AppTask]s from this trigger.
//   // List<DateTime> getSchedule(DateTime from, DateTime to);

//   @override
//   bool onInitialize() => true; // no initialize needed pr. default.

//   /// Returns a list of the running probes in this [TriggerExecutor].
//   /// This is a combination of the running probes in all task executors.
//   List<Probe> get probes {
//     List<Probe> probes = [];
//     for (var executor in executors) {
//       if (executor is TaskExecutor) {
//         probes.addAll(executor.probes);
//       }
//     }
//     return probes;
//   }
// }

// /// Abstract class for executors of triggers which can be scheduled
// /// (i.e., implementing the  [Schedulable] interface).
// abstract class SchedulableTriggerExecutor<TConfig extends TriggerConfiguration>
//     extends TriggerExecutor<TConfig> {
//   /// An ordered list of timestamp generated by this trigger for a
//   /// given period. This is mainly used for persistently scheduling
//   /// a list of [AppTask]s from triggers that implement the [Schedulable]
//   /// interface.
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max]);
// }

// /// Executes a [ImmediateTrigger], i.e. starts sampling immediately.
// class ImmediateTriggerExecutor extends TriggerExecutor<TriggerConfiguration> {}

// /// Executes a [OneTimeTrigger], i.e. a trigger that only runs once during a
// /// study deployment.
// class OneTimeTriggerExecutor extends TriggerExecutor<OneTimeTrigger> {
//   @override
//   Future<bool> onStart() async {
//     if (!configuration!.hasBeenTriggered) {
//       configuration!.triggerTimestamp = DateTime.now();
//       await super.onStart();
//     } else {
//       info(
//           "$runtimeType - one time trigger already occurred at: ${configuration?.triggerTimestamp}. "
//           'Will not trigger now.');
//     }
//     return true;
//   }
// }

// /// Executes a [PassiveTrigger].
// class PassiveTriggerExecutor extends TriggerExecutor<PassiveTrigger> {
//   PassiveTriggerExecutor() : super() {
//     configuration!.executor = ImmediateTriggerExecutor();
//     group.add(configuration!.executor.measurements);
//   }

//   // Forward to the embedded trigger executor
//   @override
//   bool onInitialize() {
//     configuration!.executor
//         .initialize(configuration as TriggerConfiguration, deployment!);
//     return true;
//   }

//   // No-op methods since a PassiveTrigger can only be resumed/paused
//   // using the resume/pause methods on the PassiveTrigger.
//   @override
//   Future<bool> onStart() async => true;
//   @override
//   Future<bool> onPause() async => true;

//   // Forward to the embedded trigger executor
//   @override
//   Future<bool> onRestart() async {
//     configuration!.executor.restart();
//     return true;
//   }

//   @override
//   Future<bool> onStop() async {
//     configuration!.executor.stop();
//     return true;
//   }
// }

// /// Executes a [DelayedTrigger], i.e. resumes sampling after the specified delay.
// /// Once started, it can be paused / resumed as any other [Executor].
// class DelayedTriggerExecutor extends TriggerExecutor<DelayedTrigger> {
//   @override
//   Future<bool> onStart() async {
//     Timer(configuration!.delay, () => super.onStart());
//     return true;
//   }
// }

// /// Executes a [ElapsedTimeTrigger], i.e. resumes sampling after the
// /// specified delay after deployment start on this phone.
// ///
// /// Once started, this trigger executor can be paused / resumed as any
// /// other [Executor].
// class ElapsedTimeTriggerExecutor
//     extends SchedulableTriggerExecutor<ElapsedTimeTrigger> {
//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int? max]) {
//     final dd = DateTime.now().add(configuration!.elapsedTimeAsDuration);
//     return (dd.isAfter(from) && dd.isBefore(to)) ? [dd] : [];
//   }

//   @override
//   Future<bool> onStart() async {
//     if (deployment?.deployed == null) {
//       warning(
//           '$runtimeType - this deployment does not have a start time. Cannot execute this trigger.');
//       return false;
//     } else {
//       int delay = configuration!.elapsedTimeAsDuration.inMilliseconds -
//           (DateTime.now().millisecondsSinceEpoch -
//               deployment!.deployed!.millisecondsSinceEpoch);

//       if (delay > 0) {
//         Timer(Duration(milliseconds: delay), () => super.onStart());
//       } else {
//         warning(
//             '$runtimeType - delay is negative, i.e. the trigger time is in the past and should have happend already.');
//       }
//     }

//     return true;
//   }
// }

// /// Executes a [IntervalTrigger], i.e. resumes sampling on a regular basis.
// class IntervalTriggerExecutor
//     extends SchedulableTriggerExecutor<IntervalTrigger> {
//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
//     final List<DateTime> schedule = [];
//     DateTime timestamp = from;
//     int count = 0;

//     while (timestamp.isBefore(to) && count < max) {
//       schedule.add(timestamp);
//       timestamp = timestamp.add(configuration!.period);
//       count++;
//     }

//     return schedule;
//   }

//   Timer? timer;

//   @override
//   Future<bool> onPause() async {
//     timer?.cancel();
//     await super.onPause();
//     return true;
//   }

//   @override
//   Future<bool> onStart() async {
//     timer = Timer.periodic(configuration!.period, (t) {
//       super.onStart();
//       Timer(const Duration(seconds: 3), () => super.onPause());
//     });
//     return true;
//   }
// }

// /// Executes a [PeriodicTrigger], i.e. resumes sampling on a regular basis for
// /// a given period of time.
// ///
// /// It is required that both the [period] and the [duration] of the
// /// [PeriodicTrigger] is specified to make sure that this executor is properly
// /// resumed and paused again.
// class PeriodicTriggerExecutor
//     extends SchedulableTriggerExecutor<PeriodicTrigger> {
//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
//     final List<DateTime> schedule = [];
//     DateTime timestamp = from;
//     int count = 0;

//     while (timestamp.isBefore(to) && count < max) {
//       schedule.add(timestamp);
//       timestamp = timestamp.add(configuration!.period);
//       count++;
//     }

//     return schedule;
//   }

//   Timer? timer;

//   @override
//   Future<bool> onPause() async {
//     timer?.cancel();
//     await super.onPause();
//     return true;
//   }

//   @override
//   Future<bool> onStart() async {
//     // create a recurrent timer that resume periodically
//     timer = Timer.periodic(configuration!.period, (t) {
//       super.onStart();
//       // create a timer that pause the sampling after the specified duration.
//       Timer(configuration!.duration, () {
//         super.onPause();
//       });
//     });
//     return true;
//   }
// }

// /// Executes a [DateTimeTrigger] on the specified date and time.
// class DateTimeTriggerExecutor
//     extends SchedulableTriggerExecutor<DateTimeTrigger> {
//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int? max]) =>
//       (configuration!.schedule.isAfter(from) &&
//               configuration!.schedule.isBefore(to))
//           ? [configuration!.schedule]
//           : [];

//   Timer? timer;

//   @override
//   Future<bool> onPause() async {
//     timer?.cancel();
//     await super.onPause();
//     return true;
//   }

//   @override
//   Future<bool> onStart() async {
//     if (configuration!.schedule.isAfter(DateTime.now())) {
//       warning('The schedule of the DateTimeTrigger cannot be in the past.');
//       return false;
//     } else {
//       var delay = configuration!.schedule.difference(DateTime.now());
//       var duration = configuration?.duration;
//       timer = Timer(delay, () {
//         // after the waiting time (delay) is over, resume this trigger
//         super.onStart();
//         if (duration != null) {
//           // create a timer that stop the sampling after the specified duration.
//           // if the duration is null, the sampling never stops, i.e. runs forever.
//           Timer(duration, () {
//             stop();
//           });
//         }
//       });
//     }
//     return true;
//   }
// }

// /// Executes a [RecurrentScheduledTrigger].
// class RecurrentScheduledTriggerExecutor
//     extends SchedulableTriggerExecutor<RecurrentScheduledTrigger> {
//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
//     List<DateTime> schedule = [];
//     DateTime timestamp = configuration!.firstOccurrence;
//     int count = 0;

//     while (timestamp.isBefore(to) && count < max) {
//       if (timestamp.isAfter(from)) schedule.add(timestamp);
//       timestamp = timestamp.add(configuration!.period);
//       count++;
//     }

//     return schedule;
//   }

//   Timer? timer;

//   @override
//   Future<bool> onPause() async {
//     timer?.cancel();
//     await super.onPause();
//     return true;
//   }

//   @override
//   Future<bool> onStart() async {
//     Duration delay = configuration!.firstOccurrence.difference(DateTime.now());
//     if (configuration!.end == null ||
//         configuration!.end!.isAfter(DateTime.now())) {
//       timer = Timer(delay, () async {
//         await super.onStart();
//       });
//     }
//     return true;
//   }
// }

// /// Executes a [CronScheduledTrigger] based on the specified cron job.
// class CronScheduledTriggerExecutor
//     extends SchedulableTriggerExecutor<CronScheduledTrigger> {
//   late cron.Cron _cron;
//   cron.ScheduledTask? _scheduledTask;

//   CronScheduledTriggerExecutor() : super() {
//     _cron = cron.Cron();
//   }

//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
//     var cronIterator = Cron().parse(
//         configuration!.cronExpression,
//         Settings().timezone,
//         tz.TZDateTime.from(from, tz.getLocation(Settings().timezone)));
//     final List<DateTime> schedule = [];
//     int count = 0;

//     while (cronIterator.next().isBefore(to) && count < max) {
//       schedule.add(cronIterator.current());
//       count++;
//     }
//     return schedule;
//   }

//   @override
//   Future<bool> onStart() async {
//     debug('creating cron job : $configuration');
//     var schedule = cron.Schedule.parse(configuration!.cronExpression);
//     _scheduledTask = _cron.schedule(schedule, () async {
//       debug('resuming cron job : ${DateTime.now().toString()}');
//       await super.onStart();
//       Timer(configuration!.duration, () => super.onPause());
//     });
//     return true;
//   }

//   @override
//   Future<bool> onPause() async {
//     await _scheduledTask?.cancel();
//     await super.onPause();
//     return true;
//   }
// }

// /// Executes a [SamplingEventTrigger] based on the specified
// /// [SamplingEventTrigger.measureType] and [SamplingEventTrigger.resumeCondition].
// class SamplingEventTriggerExecutor
//     extends TriggerExecutor<SamplingEventTrigger> {
//   StreamSubscription<Measurement>? _subscription;

//   @override
//   Future<bool> onStart() async {
//     _subscription = SmartPhoneClientManager()
//         .lookupStudyRuntime(deployment!.studyDeploymentId,
//             deployment!.deviceConfiguration.roleName)
//         ?.measurementsByType(configuration!.measureType)
//         .listen((measurement) {
//       if ((configuration!.resumeCondition != null) &&
//           measurement.data.equivalentTo(configuration!.resumeCondition!)) {
//         super.onStart();
//       }
//       if (configuration!.pauseCondition != null &&
//           measurement.data.equivalentTo(configuration!.pauseCondition!)) {
//         super.onPause();
//       }
//     });
//     return true;
//   }

//   @override
//   Future<bool> onPause() async {
//     await _subscription?.cancel();
//     await super.onPause();
//     return true;
//   }
// }

// /// Executes a [ConditionalSamplingEventTrigger] based on the specified
// /// [ConditionalSamplingEventTrigger.measureType] and their
// /// [ConditionalSamplingEventTrigger.resumeCondition] and
// /// [ConditionalSamplingEventTrigger.pauseCondition].
// class ConditionalSamplingEventTriggerExecutor
//     extends TriggerExecutor<ConditionalSamplingEventTrigger> {
//   StreamSubscription<Measurement>? _subscription;

//   @override
//   Future<bool> onStart() async {
//     // listen for event of the specified type and resume/pause as needed
//     _subscription = SmartPhoneClientManager()
//         .lookupStudyRuntime(deployment!.studyDeploymentId,
//             deployment!.deviceConfiguration.roleName)
//         ?.measurementsByType(configuration!.measureType)
//         .listen((measurement) {
//       if (configuration!.resumeCondition != null &&
//           configuration!.resumeCondition!(measurement)) super.onStart();
//       if (configuration!.pauseCondition != null &&
//           configuration!.pauseCondition!(measurement)) super.onPause();
//     });
//     return true;
//   }

//   @override
//   Future<bool> onPause() async {
//     await _subscription?.cancel();
//     await super.onPause();
//     return true;
//   }
// }

// /// Executes a [ConditionalPeriodicTrigger].
// class ConditionalPeriodicTriggerExecutor
//     extends TriggerExecutor<ConditionalPeriodicTrigger> {
//   Timer? timer;

//   @override
//   Future<bool> onStart() async {
//     // create a recurrent timer that checks the conditions periodically
//     timer = Timer.periodic(configuration!.period, (_) {
//       debug(
//           '$runtimeType - checking; resumeCondition: ${configuration!.resumeCondition}, pauseCondition: ${configuration!.pauseCondition}');
//       if (configuration!.resumeCondition != null &&
//           configuration!.resumeCondition!()) super.onStart();
//       if (configuration!.pauseCondition != null &&
//           configuration!.pauseCondition!()) super.onPause();
//     });
//     return true;
//   }

//   @override
//   Future<bool> onPause() async {
//     timer?.cancel();
//     await super.onPause();
//     return true;
//   }
// }

// /// Executes a [RandomRecurrentTrigger] triggering N times per day within a
// /// defined period of time.
// class RandomRecurrentTriggerExecutor
//     extends SchedulableTriggerExecutor<RandomRecurrentTrigger> {
//   final cron.Cron _cron = cron.Cron();
//   late cron.ScheduledTask _scheduledTask;
//   List<Timer> _timers = [];

//   TimeOfDay get startTime => configuration!.startTime;
//   TimeOfDay get endTime => configuration!.endTime;
//   int get minNumberOfTriggers => configuration!.minNumberOfTriggers;
//   int get maxNumberOfTriggers => configuration!.maxNumberOfTriggers;
//   Duration get duration => configuration!.duration;

//   /// Get a random number of samples for the day
//   int get numberOfSampling =>
//       Random().nextInt(maxNumberOfTriggers) + minNumberOfTriggers;

//   /// Get N random times between startTime and endTime
//   List<TimeOfDay> get samplingTimes {
//     List<TimeOfDay> samplingTimes = [];
//     for (int i = 0; i <= numberOfSampling; i++) {
//       samplingTimes.add(randomTime);
//     }
//     debug('Random sampling times: $samplingTimes');
//     return samplingTimes;
//   }

//   /// Get a random time between startTime and endTime
//   TimeOfDay get randomTime {
//     TimeOfDay randomTime = TimeOfDay();
//     do {
//       int randomHour = startTime.hour +
//           ((endTime.hour - startTime.hour == 0)
//               ? 0
//               : Random().nextInt(endTime.hour - startTime.hour));
//       int randomMinutes = Random().nextInt(60);
//       randomTime = TimeOfDay(hour: randomHour, minute: randomMinutes);
//     } while (!(randomTime.isAfter(startTime) && randomTime.isBefore(endTime)));

//     return randomTime;
//   }

//   String get todayString {
//     final now = DateTime.now();
//     return '${now.year}-${now.month}-${now.day}';
//   }

//   bool get hasBeenScheduledForToday {
//     // fast out if no timestamp is set previously
//     if (configuration?.lastTriggerTimestamp == null) return false;

//     final now = DateTime.now();
//     final midnight = DateTime(now.year, now.month, now.day);
//     final sinceLastTime =
//         now.millisecond - configuration!.lastTriggerTimestamp!.millisecond;
//     final sinceMidnight = now.millisecond - midnight.millisecond;

//     return (sinceLastTime < sinceMidnight);
//   }

//   @override
//   List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
//     assert(to.isAfter(from));
//     final List<DateTime> schedule = [];

//     final startDay = DateTime(from.year, from.month, from.day);
//     final toDay = DateTime(to.year, to.month, to.day);
//     var day = startDay;
//     var count = 0;

//     while (day.isBefore(toDay) && count < max) {
//       for (var time in samplingTimes) {
//         final date = DateTime(
//             day.year, day.month, day.day, time.hour, time.minute, time.second);
//         if (date.isAfter(from) && date.isBefore(to)) schedule.add(date);
//       }

//       day = day.add(const Duration(days: 1));
//       count++;
//     }
//     return schedule;
//   }

//   @override
//   Future<bool> onStart() async {
//     // sampling might be resumed after [startTime] or the app wasn't running at [startTime]
//     // therefore, first check if the random timers have been scheduled for today
//     if (TimeOfDay.now().isAfter(startTime)) {
//       if (!hasBeenScheduledForToday) {
//         debug(
//             '$runtimeType - timers has not been scheduled for today ($todayString) - scheduling now');
//         _scheduleTimers();
//       }
//     }

//     // set up a cron job that generates the random triggers once pr day at [startTime]
//     final cronJob = '${startTime.minute} ${startTime.hour} * * *';
//     debug('$runtimeType - creating cron job : $cronJob');

//     _scheduledTask = _cron.schedule(cron.Schedule.parse(cronJob), () async {
//       debug('$runtimeType - resuming cron job : ${DateTime.now().toString()}');
//       _scheduleTimers();
//     });
//     return true;
//   }

//   void _scheduleTimers() {
//     // empty the list of timers.
//     _timers = [];

//     // get a random number of trigger time for today, and for each set up a
//     // timer that triggers the super.onResume() method.
//     for (var time in samplingTimes) {
//       // find the delay - note, that none of the delays can be negative,
//       // since we are at [startTime] or after
//       Duration delay = time.difference(TimeOfDay.now());
//       debug('$runtimeType - setting up timer for : $time, delay: $delay');
//       Timer timer = Timer(delay, () async {
//         await super.onStart();
//         // now set up a timer that waits until the sampling duration ends
//         Timer(duration, () => super.onPause());
//       });
//       _timers.add(timer);
//     }

//     // mark this day as scheduled
//     configuration!.lastTriggerTimestamp = DateTime.now();
//   }

//   @override
//   Future<bool> onPause() async {
//     // cancel all the timers that might have been started
//     for (var timer in _timers) {
//       timer.cancel();
//     }
//     // cancel the daily cron job
//     await _scheduledTask.cancel();
//     return await super.onPause();
//   }
// }

// /// Executes a [UserTaskTrigger].
// class UserTaskTriggerExecutor extends TriggerExecutor<UserTaskTrigger> {
//   StreamSubscription<UserTask>? _subscription;

//   @override
//   Future<bool> onStart() async {
//     // listen for event of the specified type and resume/pause as needed
//     _subscription = AppTaskController().userTaskEvents.listen((userTask) async {
//       if (userTask.task.name == configuration!.taskName) {
//         if (userTask.state == configuration!.resumeCondition) {
//           await super.onStart();
//           if (configuration!.pauseCondition == null) super.onPause();
//         }
//         if (configuration!.pauseCondition != null &&
//             userTask.state == configuration!.pauseCondition!) super.onPause();
//       }
//     });
//     // print('>> listening to user task events - $_subscription');
//     return true;
//   }

//   @override
//   Future<bool> onPause() async {
//     await _subscription?.cancel();
//     return await super.onPause();
//   }
// }
